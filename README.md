Тестовое задание для стажировки в Naumen.
Задача: в текстовом файле даны количество клиентов N и раудиус действия станций для клиентов, в следующих N строках позиции клиентов на плоскости. Необходимо составить ТОП-10 мест для станций (чем больше клиентов покрывается станцией, тем лучше; станции можно ставить только на позиции клиентов). В файле вывода вывести номера 10 лучших позиций или меньше (если N < 10) и колчество клиентов, которые на соответсвующих позициях с данным радиусом попадают в зону действия соответсвубщей станции.
<p><b>Структура проекта, описание алгоритма</b></p>
 * <p>В методе main используются классы InputReader, StationMaster и OutputWriter. Все они отдельно задокументированы. Логика алгоритма содержится в публичных классах StationMaster, TwoDTree и QuickSelect2D.</p>
 * <p>Все множество клиентов сохраняется в сбалансированном 2D-дереве. 2D-дерево представляет собой бинарное дерево поиска. На каждом уровне все пространство точек разделяется осью, параллельной либо оси OX, либо OY. На каждом уровне узлы (которые представляют собой двумерные точки) "сортируются" поочередно по координатам X и Y. Ось на каждом уровне, которая разделяет плоскость на две части (разделяет множество всех точке на два подмножества), проходит через медианную точку этого уровня (подмножества множества всех точек). Медианная точка выбирается с помощью алгоритма QuickSelect.</p>
 * <p>QuickSelect ищет в текущем подмножестве медианную точку по оси OX или OY. В цикле while на каждой итерации мы сужаем диапазон поиска медианной точки (на первой итерации диапазон поиска - все множество, которое поступило на вход QuickSelect), пока не наткнёмся на нее случайно. На каждой итерации while выбирается опорная точка (она может выбираться произвольным образом, в этой реализации в качестве произвольной точки выбирается самая последняя (правая) точка диапазона поиска текущей итерации). Упорядочиваем текущий диапазон так, чтобы слева от опорной точки находились только "меньшие" точки, а справа - только "большие". Таким образом, мы частично упорядочиваем начальное множество по возрастанию. Смотрим на индекс опорной точки в начальном множестве. Если он равен числу МОЩНОСТЬ_МНОЖЕСТВА / (разделить нацело) 2, то мы нашли медианную точку. Если индекс текущего опорного элемента меньше МОЩНОСТЬ_МНОЖЕСТВА / 2, то дальше ищем медиану справа от опорной точки, а если больше - ищем медиану слева. Таким образом, мы получаем новый диапазон поиска, в котором на следующей итерации мы выберем новую опорную точку и проделаем то же самое.</p>
 * <p>В получившейся структуре (2D-дереве) можно быстро найти конкретную точку С или, например, узнать количество ее соседей в указанном радиусе, не перебирая все множество точек (что нам и необходимо). Идем по дереву, начиная с корня. Вычисляем дистанцию от точки C до точек в каждом узле, по которому прошлись. Если дистанция превышает радиус, то счетчик не изменяется, иначе счетчик увеличивается на 1. Принимаем решение о том, по какой ветке идти дальше (можем решить идти по обеим), исходя из координаты X или Y текущего узла. Если координата X/Y узла больше или равна значению выражения (КООРДИНАТА_C - R), то принимаем решение идти по левой ветке. Если координата X/Y узла меньше или равна значению выражения (КООРДИНАТА_C + R), то принимаем решение идти по правой ветке. Может получиться так, что мы примем решение идти по обеим ветвям. И так далее рассматриваем каждый узел, пока не дойдем до листьев или пока не перестанем встречать узлы, удовлетворяющие этим двум условиям.</p>