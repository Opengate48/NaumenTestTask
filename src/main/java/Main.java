import java.io.IOException;
import java.util.List;

/**Алгоритм для нахождения десяти позиций для станций такси, на которых станции покрывают максимальное число клиентов в указанном радиусе. Алгоритм основывается на структуре сбалансированного 2D-дерева (частного случая KD-дерева). В балансировке дерева участвует общеизвестный алгоритм QuickSelect.
 * <p><b>Важно</b></p>
 * <p>Алгоритм не ищет такие позиции для станций, которые обеспечивают максимальное покрытие всех станций в совокупности. Алгоритм лишь ищет топ-10 позиций, на которых каждая станция покрывает максимально возможное клличество клиентов. Т.е., в результате может получиться множество позиций для станций, в котором станции покрывают клиентов, которые были уже покрыты другими станциями. Такой алгоритм обусловлен примерами из ТЗ.</p>
 * <p>Н-р, содержимое input.txt из примеров:</p>
 * <p>10 3.000000</p>
 * <p>3.168070 1.752490</p>
 * <p>0.500730 6.436580</p>
 * <p>0.089300 0.112720</p>
 * <p>2.275440 7.508780</p>
 * <p>0.779230 4.377090</p>
 * <p>0.644400 1.381650</p>
 * <p>1.844920 1.430420</p>
 * <p>8.079870 5.225030</p>
 * <p>7.823270 5.317290</p>
 * <p>1.788400 5.426120</p>
 * <p>Содержимое output.txt из примеров</p>
 * <p>5 4</p>
 * <p>1 3</p>
 * <p>4 3</p>
 * <p>6 3</p>
 * <p>9 3</p>
 * <p>0 2</p>
 * <p>2 2</p>
 * <p>3 2</p>
 * <p>7 1</p>
 * <p>8 1</p>
 * <p>Тут можно было обойтись всего тремя станциями, которые покрывали бы всех клиентов, но использовали все 10 станций.</p>
 * <p><b>Структура проекта, описание алгоритма</b></p>
 * <p>В методе main используются классы InputReader, StationMaster и OutputWriter. Все они отдельно задокументированы. Логика алгоритма содержится в публичных классах StationMaster, TwoDTree и QuickSelect2D.</p>
 * <p>Все множество клиентов сохраняется в сбалансированном 2D-дереве. 2D-дерево представляет собой бинарное дерево поиска. На каждом уровне все пространство точек разделяется осью, параллельной либо оси OX, либо OY. На каждом уровне узлы (которые представляют собой двумерные точки) "сортируются" поочередно по координатам X и Y. Ось на каждом уровне, которая разделяет плоскость на две части (разделяет множество всех точке на два подмножества), проходит через медианную точку этого уровня (подмножества множества всех точек). Медианная точка выбирается с помощью алгоритма QuickSelect.</p>
 * <p>QuickSelect ищет в текущем подмножестве медианную точку по оси OX или OY. В цикле while на каждой итерации мы сужаем диапазон поиска медианной точки (на первой итерации диапазон поиска - все множество, которое поступило на вход QuickSelect), пока не наткнёмся на нее случайно. На каждой итерации while выбирается опорная точка (она может выбираться произвольным образом, в этой реализации в качестве произвольной точки выбирается самая последняя (правая) точка диапазона поиска текущей итерации). Упорядочиваем текущий диапазон так, чтобы слева от опорной точки находились только "меньшие" точки, а справа - только "большие". Таким образом, мы частично упорядочиваем начальное множество по возрастанию. Смотрим на индекс опорной точки в начальном множестве. Если он равен числу МОЩНОСТЬ_МНОЖЕСТВА / (разделить нацело) 2, то мы нашли медианную точку. Если индекс текущего опорного элемента меньше МОЩНОСТЬ_МНОЖЕСТВА / 2, то дальше ищем медиану справа от опорной точки, а если больше - ищем медиану слева. Таким образом, мы получаем новый диапазон поиска, в котором на следующей итерации мы выберем новую опорную точку и проделаем то же самое.</p>
 * <p>В получившейся структуре (2D-дереве) можно быстро найти конкретную точку С или, например, узнать количество ее соседей в указанном радиусе, не перебирая все множество точек (что нам и необходимо). Идем по дереву, начиная с корня. Вычисляем дистанцию от точки C до точек в каждом узле, по которому прошлись. Если дистанция превышает радиус, то счетчик не изменяется, иначе счетчик увеличивается на 1. Принимаем решение о том, по какой ветке идти дальше (можем решить идти по обеим), исходя из координаты X или Y текущего узла. Если координата X/Y узла больше или равна значению выражения (КООРДИНАТА_C - R), то принимаем решение идти по левой ветке. Если координата X/Y узла меньше или равна значению выражения (КООРДИНАТА_C + R), то принимаем решение идти по правой ветке. Может получиться так, что мы примем решение идти по обеим ветвям. И так далее рассматриваем каждый узел, пока не дойдем до листьев или пока не перестанем встречать узлы, удовлетворяющие этим двум условиям.</p>
 * @author Лагунов Макар Тарасович
 */
public class Main {
    public static void main(String[] args) {
        long startTime = System.nanoTime();
        InputReader reader = new InputReader();
        try {
            InputReader.ReadResult result = reader.read("input.txt");
            List<Client> clients = result.getClients();
            double R = result.getRadius();

            StationMaster solver = new StationMaster();
            List<Station> solution = solver.getSimpleSolution(clients, R); // Пример R=3.0

            OutputWriter writer = new OutputWriter();
            writer.write(solution, "output.txt");

        } catch (IOException e) {
            System.err.println(e.getMessage());
            System.err.println("Стек вызовов:");
            e.printStackTrace(System.err);
            System.exit(1);
        } catch (IllegalArgumentException e){
            System.err.println(e.getMessage());
            System.err.println("Стек вызовов:");
            e.printStackTrace(System.err);
            System.exit(1);
        } catch (NullPointerException e){
            System.err.println(e.getMessage());
            System.err.println("Стек вызовов:");
            e.printStackTrace(System.err);
            System.exit(1);
        }
        long endTime = System.nanoTime();
        double durationSeconds = (endTime - startTime) / 1_000_000_000.0;
        System.out.printf("Время выполнения: %.3f секунд%n", durationSeconds);
    }
}